//算法思想：满二叉树的先序遍历，第一个元素是根结点，接下来的元素一半长度是左子树，一半长度是右子树，转换成后序遍历需要将根结点移动到最后
//同理，依次处理左子树，右子树，至序列全部转换成后序遍历
void change(char pre[], char post[], int l1 , int r1, int l2, int r2) {
	if (l1 <= r1) {
		post[r2] = pre[l1];         //将pre[]第一个元素放到post[]的末尾

		//计算pre[]边界：l1 + 1, r1，则一半的位置为(l1 + 1 + r1) / 2
		//计算post[]边界：l2, r2 -1，则一半的位置为(l2 + r2 - 1) / 2
		change(pre, post, l1 + 1, (l1 + 1 + r1) / 2, l2, (l2 + r2 - 1) / 2);   //处理前一半
		change(pre, post, (l1 + 1 + r1) / 2 + 1, r1, (l2 + r2 - 1) / 2 + 1, r2 - 1); // 处理后一半
	}
}
